{"version":3,"file":"main.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;AC9CtB;AACA;AACA,kBAAkB,yBAAyB;AAC3C;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,iCAAiC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;AC7CtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,kCAAkC,qBAAqB,KAAK,GAAG;AAC/D;;AAEA;AACA;AACA,uBAAuB,WAAW;AAClC,yBAAyB,WAAW;AACpC;AACA;AACA;AACA;AACA;;AAEuB;;;;;;;;;;;;;;;;;;;;AC7BvB;AAC0D;AAMjC;AACa;AACiC;AAC/B;;AAEjC;AACP,gBAAgB,uEAAkB;;AAElC,EAAE,6CAAE;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,YAAY,QAAQ;AACpB;AACA,IAAI,+CAAI,aAAa,QAAQ,gEAAkB,aAAa;AAC5D;;AAEA;AACA;;AAEA;AACA;AACA,8BAA8B,qDAAS;AACvC;AACA,sDAAsD,iBAAiB;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA,IAAI,6DAAa;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,gEAAgB;AACpC,2BAA2B,kEAAkB;AAC7C;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,uEAAuB;AAC3B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,mBAAmB;AAC/D;AACA,+BAA+B,UAAU,SAAS,QAAQ;AAC1D,kCAAkC,UAAU,SAAS,QAAQ;AAC7D;;AAEA;AACA;AACA,kBAAkB,gEAAkB;AACpC,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5IA;AAC2C;AACF;AACD;;AAExC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,kCAAkC,mBAAmB;AACrD;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,gCAAgC,sDAAW;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,EAAE,wDAAY;AACd,+CAA+C,UAAU;AACzD,4CAA4C,UAAU;AACtD,+CAA+C,UAAU;AACzD,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sDAAW;AAC3C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD,UAAU;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA,0BAA0B,wDAAW;AACrC;AACA;AACA;;AAEA;AACA;AACA,6BAA6B,0BAA0B;AACvD;AACA;AACA;;AAiBE;;;;;;;;;;;;;;;ACjNF;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA,uCAAuC,0BAA0B,IAAI,gBAAgB;AACrF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;;;;;;;AC5BqB;AACb;AACqB;AACK;AACvB;AACG;AACX;;AAEjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAqC,sDAAW;AAChD;AACA;AACA,EAAE,yDAAS;AACX,iDAAiD,+CAAI,iCAAiC,YAAY;AAClG,EAAE,6CAAE;AACJ,EAAE,6CAAE;AACJ;;AAEA;AACA,gBAAgB,4CAAc;AAC9B;AACA,sCAAsC,iDAAS;AAC/C,uCAAuC,iDAAS;AAChD;AACA;AACA,EAAE,0DAAc,SAAS;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA,qCAAqC,sDAAW;AAChD;AACA,EAAE,+CAAI;AACN;;AAEA;AACA;;AAEA;AACA,UAAU,mCAAmC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,IAAI,6DAAiB;AACrB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,6DAAiB;AACnB,kCAAkC,qDAAqD;AACvF;AACA,GAAG;AACH,qCAAqC,2CAA2C,SAAS,cAAc;;AAEvG;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qCAAqC,WAAW;AAChD;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,4CAAc;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM,8CAAO;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEwF;;;;;;;;;;;;;;;;;;;;;;;AClNxF;AACiC;AACU;AACA;AACA;AACA;AACH;AACC;AACU;;AAEpC;AACf;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,GAAG,sDAAW;AACzC,0BAA0B,4DAAkB;AAC5C,kBAAkB,IAAI,qDAAS,IAAI;AACnC;AACA,oBAAoB,IAAI,qDAAS,IAAI;AACrC;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B,oBAAoB,IAAI,qDAAS,IAAI;AACrC,sBAAsB,IAAI,qDAAS,IAAI;AACvC,mCAAmC,mCAAmC;AACtE;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,6CAAE,mCAAmC;AACzC,IAAI,6CAAE,+BAA+B;AACrC;;AAEA;AACA,IAAI,8CAAG;AACP,IAAI,8CAAG;AACP,wCAAwC;;AAExC,kBAAkB,wDAAW;AAC7B;AACA;AACA,KAAK;AACL;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,oFAAoF,qDAAS;;AAE7F;AACA;AACA;;AAEA,oBAAoB,iDAAW;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA,EAAE,6CAAE;;AAEJ;AACA;;AAEA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+CAAI,kBAAkB,aAAa;AACvC;;AAEA;AACA;AACA;AACA;AACA,IAAI,+CAAI,WAAW,4BAA4B;AAC/C;;AAEA,wBAAwB;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,IAAI,qDAAS,IAAI;AACrC,sBAAsB,IAAI,qDAAS,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,aAAa,wDAAU;AACvB;AACA,WAAW,wDAAU;AACrB;;AAEA;AACA;AACA,oBAAoB,oBAAoB;AACxC,sBAAsB,oBAAoB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;;;;;;;;;;;;;;;ACjNA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;;;ACVK;;AAExC;AACA,eAAe,qDAAS;AACxB;AACA;AACA;AACA;;AAEA;AACA,eAAe,qDAAS;AACxB;AACA;;AAEkD;;;;;;;;;;;;;;;;;ACdlD;AACkC;;AAElC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+CAAI;AACV,KAAK;AACL,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+CAAI;AACV,KAAK;AACL,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,EAAE,+CAAI;AACN;;AAEA;AACA;AACA;AACA;;AAEwC;;;;;;;;;;;;;;;;;;ACzDxC;AACuE;;AAEvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;;AAEH,8CAA8C,gEAAkB;AAChE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,gBAAgB,gEAAkB;AAClC;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gEAAkB;AACtC;AACA,OAAO;AACP,GAAG;AACH;AACA;;AAE4D;;;;;;;;;;;;;;;;ACvE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEoC;;;;;;;;;;;;;;;;;;;;;;ACpFpC;AACmC;AACkC;AACxB;AAcpB;AACe;AACe;AACD;AACb;AACU;AAClB;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,uCAAuC,uDAAW;AAClD,uCAAuC,uDAAW;AAClD;;AAEA,qBAAqB,gEAAkB;AACvC,qBAAqB,gEAAkB;;AAEvC;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB;;AAEnB;AACA,EAAE,sDAAW;AACb,EAAE,iEAAiB;AACnB,EAAE,6DAAa;AACf,EAAE,8CAAO;AACT;AACA,iBAAiB,kDAAY;AAC7B,iBAAiB,kDAAY;AAC7B,cAAc,0DAAe,WAAW,qDAAS;AACjD,cAAc,0DAAe,WAAW,qDAAS;AACjD,YAAY,2DAAkB;AAC9B;AACA;AACA,QAAQ,8DAAqB;AAC7B,mBAAmB,2DAAkB;AACrC;AACA;AACA,0DAA0D,YAAY;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,0DAA0D,YAAY;AACtE;AACA;;AAEA;AACA,EAAE,gEAAgB;AAClB,EAAE,+DAAe;AACjB;AACA;AACA,EAAE,6CAAE;AACJ,EAAE,6CAAE,SAAS,uDAAW;AACxB,EAAE,6CAAE,SAAS,6DAAiB;AAC9B,EAAE,6CAAE,oCAAoC,sDAAsD;AAC9F,EAAE,6CAAE,cAAc,wDAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0DAAU;AACd,IAAI;AACJ,IAAI,2DAAW;AACf;AACA,MAAM,0DAAU;AAChB;AACA,KAAK,SAAS;AACd;AACA;;AAEA;AACA,EAAE,gEAAgB;AAClB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE,+CAAI;AACN;AACA;AACA;;AAEA;AACA,EAAE,wDAAQ;AACV,EAAE,0DAAe;AACjB,EAAE,mEAAkB;AACpB;AACA;AACA;AACA,6DAA6D,YAAY;AACzE,2DAA2D,YAAY;AACvE;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/NA;AACsD;;AAEtD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,KAAK;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD,0BAA0B,0BAA0B;AACpD;;AAEA;AACA;AACA,EAAE,mEAAuB;AACzB;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAuBE;;;;;;;;;;;;;;;;ACvIF;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;ACTO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACzCA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,8BAA8B;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAE0C;;;;;;;;;;;;;;;;;;;AC5BF;AACC;AACmC;;AAE5E;AACA,gBAAgB,sDAAW;;AAE3B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;;AAEA;AACA,gBAAgB,sDAAW;AAC3B,eAAe,qDAAS;AACxB;AACA,kBAAkB,UAAU;AAC5B,oBAAoB,UAAU;AAC9B;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,QAAQ,2DAAkB;AAC1B,QAAQ,yDAAgB;;AAExB,iBAAiB,mDAAU;AAC3B,kCAAkC,oCAAoC;AACtE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,WAAW;AACX;;AAEqD;;;;;;;;;;;;;;;;;;AC3FrD;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,iDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,+CAA+C,sBAAsB,WAAW,SAAS;AACzF;AACA;AACA,6EAA6E,SAAS;AACtF;AACA;AACA,+CAA+C,qBAAqB,WAAW,SAAS;AACxF;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,gBAAgB;AAC1B;AACA,4EAA4E;AAC5E,IAAI;AACJ,2EAA2E;AAC3E;AACA;;AAE8E;;;;;;;;;;;;;;;AC5C/D;AACf;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,WAAW;AACX;;;;;;;;;;;;;;;ACZe;AACf,YAAY,OAAO,KAAK,gBAAgB,EAAE,YAAY;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;ACrBA;AACyC;AACE;;AAE5B;AACf;;AAEA;AACA,oBAAoB,iBAAiB;AACrC,cAAc,OAAO;AACrB,kCAAkC,sDAAW;AAC7C;AACA,kBAAkB,wDAAU;AAC5B;AACA;;AAEA;AACA,sDAAsD,KAAK;AAC3D,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;UCvFA;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;ACNoB","sources":["webpack://battleship/./src/1DSetFinder.js","webpack://battleship/./src/2DSetFinder.js","webpack://battleship/./src/DOMAdapter.js","webpack://battleship/./src/DOMBoard.js","webpack://battleship/./src/DOMController.js","webpack://battleship/./src/DOMInitializeBoard.js","webpack://battleship/./src/DOMSetupBoard.js","webpack://battleship/./src/board.js","webpack://battleship/./src/boardSize.js","webpack://battleship/./src/coordinates.js","webpack://battleship/./src/draggable.js","webpack://battleship/./src/engine.js","webpack://battleship/./src/ensemble.js","webpack://battleship/./src/gameflow.js","webpack://battleship/./src/imageGenerator.js","webpack://battleship/./src/mode.js","webpack://battleship/./src/moveTracker.js","webpack://battleship/./src/observer.js","webpack://battleship/./src/player.js","webpack://battleship/./src/rotatable.js","webpack://battleship/./src/ship.js","webpack://battleship/./src/sunkMessage.js","webpack://battleship/./src/unresolvedShips.js","webpack://battleship/webpack/bootstrap","webpack://battleship/webpack/runtime/define property getters","webpack://battleship/webpack/runtime/hasOwnProperty shorthand","webpack://battleship/webpack/runtime/make namespace object","webpack://battleship/./src/index.js"],"sourcesContent":["function find1DSets(board, length, exclusionCondition) {\n  if (length === 1) return board.emptySquares();\n  const sets = [];\n  for (let i = 0; i < board.size; i++) {\n    const horizontal = [];\n    const vertical = [];\n    for (let j = 0; j < board.size; j++) {\n      horizontal.push([j, i]);\n      vertical.push([i, j]);\n    }\n    sets.push(\n      ...findSetsFromLine(horizontal, length, exclusionCondition),\n      ...findSetsFromLine(vertical, length, exclusionCondition),\n    );\n  }\n  if (sets.length === 0) throw new Error('No sets found with given parameters');\n  return sets;\n}\n\nfunction findSetsFromLine(line, length, exclusionCondition) {\n  let lft = 0;\n  let rt = 1;\n  const sets = [];\n\n  while (rt < line.length) {\n    if (exclusionCondition([line[lft]])) {\n      lft = rt;\n      rt += 1;\n    } else if (exclusionCondition([line[rt]])) {\n      lft = rt + 1;\n      rt += 2;\n    } else if (rt - lft + 1 === length) {\n      const set = [];\n      for (let j = lft; j <= rt; j++) {\n        set.push(line[j]);\n      }\n      sets.push(set);\n      lft++;\n      rt++;\n    } else {\n      rt++;\n    }\n  }\n  return sets;\n}\n\nexport { find1DSets };\n","function find2DSets(board, width, height, exclusionCondition) {\n  const sets = [];\n  for (let i = 0; i <= board.size - width; i++) {\n    const rows = [];\n    const columns = [];\n    for (let j = 0; j < board.size; j++) {\n      rows.push(createXComponent(j, i, width));\n      if (width !== height) columns.push(createYComponent(j, i, width));\n    }\n    sets.push(\n      ...findSetsFromComponents(rows, height, exclusionCondition),\n      ...findSetsFromComponents(columns, height, exclusionCondition) // empty array if width === height\n    );\n  }\n  if (sets.length === 0) throw new Error('No sets found with given parameters');\n  return sets;\n}\n\nfunction createXComponent(fixed, variable, length) {\n  const component = [];\n  for (let idx = 0; idx < length; idx++) {\n    component.push([variable + idx, fixed]);\n  }\n  return component;\n}\n\nfunction createYComponent(fixed, variable, length) {\n  const component = [];\n  for (let idx = 0; idx < length; idx++) {\n    component.push([fixed, variable + idx]);\n  }\n  return component;\n}\n\nfunction findSetsFromComponents(components, length, exclusionCondition) {\n  const sets = [];\n  for (let i = 0; i <= components.length - length; i++) {\n    const candidateSet = components.slice(i, i + length).flat();\n    if (!exclusionCondition(candidateSet)) {\n      sets.push(candidateSet);\n    }\n  }\n  return sets;\n}\n\nexport { find2DSets };\n","function getShipData(DOMboard) {\n  return Array.from(DOMboard.children)\n    .filter((element) => element.classList.contains('placed-img-wrapper'))\n    .map((element) => {\n      const [rowStart, colStart, rowSpan, colSpan] = element.style.gridArea\n        .match(/\\d+/g)\n        .map(Number);\n      const yStart = rowStart - 1;\n      const yEnd = yStart + rowSpan - 1;\n      const xStart = colStart - 1;\n      const xEnd = xStart + colSpan - 1;\n      const name = element.firstChild.type;\n      const object = {};\n      object[name] = getCoordinates(xStart, xEnd, yStart, yEnd);\n      return object;\n    })\n    .reduce((object, entry) => ({ ...object, ...entry }), {}); // converts array of objects into 1 object\n}\n\nfunction getCoordinates(xStart, xEnd, yStart, yEnd) {\n  const set = [];\n  for (let x = xStart; x <= xEnd; x++) {\n    for (let y = yStart; y <= yEnd; y++) {\n      set.push([x, y]);\n    }\n  }\n  return set;\n}\n\nexport { getShipData };\n","/* eslint-disable no-param-reassign */\nimport { initializeDOMBoard } from './DOMInitializeBoard';\nimport {\n  setupDOMBoard,\n  newTemplateImage,\n  newTemplateWrapper,\n  disableAllPreviewImages,\n} from './DOMSetupBoard';\nimport { on, emit } from './observer';\nimport { coordinatesToIndex, indexToCoordinates } from './coordinates';\nimport { rowLength } from './boardSize';\n\nexport function DOMBoardFactory(id, ROWS) {\n  const board = initializeDOMBoard(id, ROWS);\n\n  on('boardChange', updateBoard);\n\n  function listenForAttack() {\n    board.addEventListener('click', receiveAttack);\n  }\n\n  function unlistenForAttack() {\n    board.removeEventListener('click', receiveAttack);\n  }\n\n  function setOffense() {\n    board.classList.remove('defense');\n    board.classList.add('offense');\n  }\n\n  function setDefense() {\n    board.classList.remove('offense');\n    board.classList.add('defense');\n  }\n\n  function disable() {\n    board.classList.add('disabled');\n  }\n\n  function enable() {\n    board.classList.remove('disabled');\n  }\n\n  function setGameOver() {\n    board.classList.add('disabled');\n    board.classList.add('game-over');\n  }\n\n  function receiveAttack(e) {\n    const { index } = e.target.dataset;\n    if (!index) return;\n    emit('attack', { coords: indexToCoordinates(index), id });\n  }\n\n  function updateBoard(boardData) {\n    if (boardData.id !== id) return;\n\n    boardData.squares.forEach((row, i) => {\n      row.forEach((square, j) => {\n        const index = i + j * rowLength();\n        if (square.ship?.isSunk()) {\n          const img = board.querySelector(`img[src*=${square.ship.name}].placed-img`);\n          img.parentElement.classList.add('sunk');\n          board.cells[index].classList.add('sunk');\n        }\n        if (square.sunkInstrument) {\n          board.cells[index].classList.add('final-attack');\n        }\n        if (square.attacked) {\n          board.cells[index].classList.add('attacked');\n        }\n      });\n    });\n  }\n\n  function setupBoard() {\n    setupDOMBoard(board);\n  }\n\n  function clearBoard() {\n    const children = Array.from(board.children);\n    children.forEach((node) => {\n      if (node.classList.contains('permanent')) {\n        return;\n      }\n      if (node.classList.contains('cell')) {\n        node.classList.remove('highlight-placed');\n        return;\n      }\n      node.remove();\n    });\n  }\n\n  function placeSetImages(dataBoard) {\n    // places on DOMboard (board variable) all images from board object argument\n    clearBoard();\n    dataBoard.placedShips.forEach((ship) => {\n      const image = newTemplateImage(ship.name);\n      const imageWrapper = newTemplateWrapper();\n      setPosition(image, imageWrapper, ship.coords);\n      addPlacedClass(ship.coords);\n      imageWrapper.appendChild(image);\n      board.appendChild(imageWrapper);\n    });\n    disableAllPreviewImages();\n  }\n\n  function setPosition(image, wrapper, set) {\n    const rowStart = set.reduce((min, coord) => (coord[1] < min ? coord[1] : min), 100) + 1;\n    const rowSpan = set.reduce((max, coord) => (coord[1] > max ? coord[1] : max), -100) + 2 - rowStart;\n    const colStart = set.reduce((min, coord) => (coord[0] < min ? coord[0] : min), 100) + 1;\n    const colSpan = set.reduce((max, coord) => (coord[0] > max ? coord[0] : max), -100) + 2 - colStart;\n\n    if (\n      (colSpan > rowSpan && image.type !== 'glockenspiel') ||\n      (colSpan < rowSpan && image.type === 'glockenspiel')\n    ) {\n      image.style.transform = `translateX(${image.style.height}) rotate(90deg)`;\n    }\n    wrapper.style.gridRow = `${rowStart} / span ${rowSpan}`;\n    wrapper.style.gridColumn = `${colStart} / span ${colSpan}`;\n  }\n\n  function addPlacedClass(set) {\n    set.forEach((coords) => {\n      board.cells[coordinatesToIndex(coords)].classList.add('highlight-placed');\n    });\n  }\n\n  return {\n    setOffense,\n    setDefense,\n    setupBoard,\n    placeSetImages,\n    listenForAttack,\n    unlistenForAttack,\n    disable,\n    enable,\n    setGameOver,\n  };\n}\n","/* eslint-disable no-param-reassign */\nimport { setRowLength } from './boardSize';\nimport { getEnsemble } from './ensemble';\nimport sunkMessage from './sunkMessage';\n\nconst controlPanel = document.querySelector('.control-panel');\nconst startRoundButton = document.querySelector('.start-round');\n\nconst setupContainer = document.querySelector('.board-setup-container');\nconst stagingArea = document.querySelector('.staging-area');\n\nconst board1 = document.querySelector('#board1');\nconst board2 = document.querySelector('#board2');\nconst fleetContainers = document.querySelectorAll('.remaining-fleet');\nconst fleet = document.querySelectorAll('.fleet');\nconst attackDirection = document.querySelector('.attack-direction');\nconst gameState = document.querySelector('.game-state');\n\nconst switchButton = document.querySelector('.switch-turns');\nconst curtains = document.querySelectorAll('.curtain');\nconst infoButtons = document.querySelectorAll('.info');\nconst intro = document.querySelector('.intro-text');\n\nconst moveTrackers = document.querySelectorAll('.moves');\n\nconst broadcast1 = board1.querySelector('.broadcast');\nconst broadcast2 = board2.querySelector('.broadcast');\n\nfunction setWindowHeight() {\n  document.body.style.height = `${window.innerHeight}px`;\n}\n\nsetWindowHeight();\nwindow.addEventListener('resize', setWindowHeight);\n\nfunction resetDOM() {\n  board1.classList.add('hidden');\n  board2.classList.add('hidden');\n  board1.classList.remove('defense');\n  board2.classList.remove('defense');\n  board1.classList.remove('offense');\n  board2.classList.remove('offense');\n  board1.classList.remove('game-over');\n  board2.classList.remove('game-over');\n  setupContainer.classList.add('hidden');\n  controlPanel.classList.remove('setup');\n  controlPanel.classList.remove('in-game');\n  controlPanel.classList.remove('two-player');\n  controlPanel.classList.add('preferences');\n  curtains.forEach((curtain) => curtain.classList.add('invisible'));\n  fleetContainers.forEach((container) => {\n    container.classList.add('invisible');\n    container.classList.add('opaque');\n    container.classList.remove('active');\n  });\n  fleet.forEach((instrument) => instrument.classList.remove('sunk'));\n  attackDirection.classList.add('invisible');\n  attackDirection.classList.remove('player2');\n  broadcast1.classList.remove('game-over');\n  broadcast2.classList.remove('game-over');\n  broadcast1.classList.remove('active');\n  broadcast2.classList.remove('active');\n  gameState.textContent = 'Attack!';\n  moveTrackers.forEach((tracker) => tracker.classList.add('invisible'));\n  infoButtons.forEach((button) => {\n    button.classList.add('hidden');\n    button.textContent = 'info';\n  });\n  stagingArea.innerHTML = '';\n  stagingArea.classList.remove('small-board');\n}\n\nfunction showSetup(board) {\n  setupContainer.classList.remove('hidden');\n  board.classList.remove('hidden');\n  if (board1 === board) {\n    board2.classList.add('hidden');\n  } else {\n    board1.classList.add('hidden');\n  }\n  const previews = document.querySelectorAll('.img-preview');\n  const whiteList = Object.keys(getEnsemble());\n  previews.forEach((preview) => {\n    if (whiteList.includes(preview.dataset.inst)) {\n      preview.classList.remove('hidden');\n    } else {\n      preview.classList.add('hidden');\n    }\n  });\n}\n\nfunction setBoardSizes() {\n  const rowLength = Number(document.querySelector('.size-select').value) || 10;\n  setRowLength(rowLength);\n  board1.style.gridTemplateColumns = `repeat(${rowLength}, 1fr)`;\n  board1.style.gridTemplateRows = `repeat(${rowLength}, 1fr)`;\n  board2.style.gridTemplateColumns = `repeat(${rowLength}, 1fr)`;\n  board2.style.gridTemplateRows = `repeat(${rowLength}, 1fr)`;\n  if (rowLength === 7) {\n    stagingArea.classList.add('small-board');\n  }\n}\n\nfunction showBoards() {\n  setupContainer.classList.add('hidden');\n  board1.classList.remove('hidden');\n  board2.classList.remove('hidden');\n  setTimeout(() => fleetContainers.forEach((container) => container.classList.remove('invisible')), 50);\n  const whiteList = Object.keys(getEnsemble());\n  fleet.forEach((instrument) => {\n    if (whiteList.includes(instrument.dataset.inst)) {\n      instrument.classList.remove('hidden');\n    } else {\n      instrument.classList.add('hidden');\n    }\n  });\n}\n\nfunction setPlayRoundView() {\n  curtains.forEach((curtain) => curtain.classList.add('invisible'));\n  uncoverFleets();\n  attackDirection.classList.remove('invisible');\n  attackDirection.classList.remove('opaque');\n  switchButton.disabled = true;\n  startRoundButton.disabled = true;\n}\n\nfunction updateFleet(data) {\n  const targetContainer = data.id === 'board1' ? board1 : board2;\n  const target = targetContainer.querySelector(`.${data.inst}`);\n  target.classList.add('sunk');\n}\n\nfunction coverBoards() {\n  curtains.forEach((curtain) => curtain.classList.remove('invisible'));\n  setTimeout(() => {\n    startRoundButton.disabled = false;\n  }, 2000);\n  switchButton.disabled = true;\n  moveTrackers.forEach((tracker) => tracker.classList.add('hidden'));\n  fleetContainers.forEach((container) => container.classList.remove('active'));\n  infoButtons.forEach((button) => {\n    button.textContent = 'info';\n  });\n}\n\nfunction coverFleets() {\n  fleetContainers.forEach((container) => container.classList.add('opaque'));\n}\n\nfunction uncoverFleets() {\n  fleetContainers.forEach((container) => container.classList.remove('opaque'));\n}\n\nfunction setSetupPanelView() {\n  intro.classList.add('hidden');\n  controlPanel.classList.remove('preferences');\n  controlPanel.classList.add('setup');\n}\n\nfunction setGamePanelView() {\n  controlPanel.classList.remove('setup');\n  controlPanel.classList.add('in-game');\n}\n\nfunction showInfoButtons() {\n  infoButtons.forEach((button) => button.classList.remove('hidden'));\n}\n\ninfoButtons.forEach((button) =>\n  button.addEventListener('click', () => {\n    const currentIcon = button.textContent;\n    button.textContent = currentIcon === 'info' ? 'cancel' : 'info';\n\n    const targetBoard = button.dataset.board === '1' ? board1 : board2;\n    const targetFleetContainer = targetBoard.querySelector('.remaining-fleet');\n    targetFleetContainer.classList.toggle('active');\n  })\n);\n\nfunction broadcastSunkShip(data) {\n  const broadcast = data.id === 'board1' ? broadcast1 : broadcast2;\n  broadcast.textContent = sunkMessage(broadcast.dataset.player, data.inst);\n  broadcast.classList.add('active');\n  setTimeout(() => broadcast.classList.remove('active'), 2000);\n}\n\nfunction broadcastWin(id) {\n  const broadcast = id === 1 ? broadcast1 : broadcast2;\n  broadcast.textContent = `${broadcast.dataset.player} Wins!`;\n  broadcast.classList.add('game-over');\n  broadcast.classList.add('active');\n}\n\nexport {\n  showBoards,\n  showSetup,\n  setBoardSizes,\n  setPlayRoundView,\n  setSetupPanelView,\n  setGamePanelView,\n  resetDOM,\n  coverBoards,\n  updateFleet,\n  coverFleets,\n  uncoverFleets,\n  showInfoButtons,\n  broadcastSunkShip,\n  broadcastWin\n};\n","/* eslint-disable no-param-reassign */\nfunction createGrid(rows, board) {\n  // HTML element remains after a reset; revert back to initial state\n  const children = Array.from(board.children);\n  children.forEach((node) => {\n    if (node.classList.contains('permanent')) {\n      return;\n    }\n    node.remove();\n  });\n\n  board.cells = [];\n  for (let i = 0; i < rows * rows; i++) {\n    board.cells[i] = document.createElement('div');\n    board.cells[i].classList.add('cell');\n    board.cells[i].style.gridArea = `${Math.floor(i / rows) + 1} / ${(i % rows) + 1} / span 1 / span 1`;\n    board.cells[i].dataset.index = i;\n    board.appendChild(board.cells[i]);\n  }\n}\n\nfunction initializeDOMBoard(id, rows) {\n  const board = document.getElementById(id);\n  board.numRows = rows;\n  createGrid(rows, board);\n  return board;\n}\n\nexport { initializeDOMBoard };\n","import * as imageGenerator from './imageGenerator';\nimport { on, emit } from './observer';\nimport { dragStart, resetDraggedImage } from './draggable';\nimport { setStagedImage, adjustForRotation } from './rotatable';\nimport { getEnsemble } from './ensemble';\nimport { showSetup } from './DOMController';\nimport { getMode } from './mode';\n\nconst stagingArea = document.querySelector('.staging-area');\nconst previewContainer = document.querySelector('.preview-container');\nconst previews = document.querySelectorAll('.img-preview');\nconst setBoardButton = document.querySelector('.set-board');\nconst clearButton = document.querySelector('.clear');\nconst autoSetupButton = document.querySelector('.random');\n\npreviews.forEach((preview) => preview.addEventListener('click', showStagedImage));\nclearButton.addEventListener('click', clearPlacedImages);\nautoSetupButton.addEventListener('click', removeStagedImage);\n\nlet remainingInstruments;\nlet currentBoard;\nfunction setupDOMBoard(board) {\n  setBoardButton.disabled = true;\n  remainingInstruments = Object.keys(getEnsemble());\n  enablePreviewImages();\n  currentBoard = board;\n  showSetup(currentBoard);\n  setBoardButton.addEventListener('click', () => emit('setPosition', currentBoard), { once: true });\n  on('dragEvent', highlightHoveredCells);\n  on('dragEnd', handleRelease);\n}\n\nfunction showStagedImage() {\n  const image = imageGenerator[this.dataset.inst]();\n  image.classList.add('staging-img');\n  image.addEventListener('mousedown', dragStart);\n  image.addEventListener('touchstart', dragStart);\n  removeStagedImage();\n  stagingArea.appendChild(image);\n  setStagedImage(image); // for rotation\n}\n\nfunction removeStagedImage() {\n  if (stagingArea.firstChild) {\n    stagingArea.firstChild.removeResizeListener();\n    stagingArea.removeChild(stagingArea.firstChild);\n  }\n}\n\nfunction clearPlacedImages() {\n  const children = Array.from(currentBoard.children);\n  children.forEach((element) => {\n    if (element.classList.contains('placed-img-wrapper')) {\n      element.firstChild.removeResizeListener();\n      element.remove();\n    } else {\n      element.classList.remove('highlight-placed');\n    }\n  });\n  previews.forEach((preview) => preview.classList.remove('disabled'));\n  removeStagedImage();\n  remainingInstruments = Object.keys(getEnsemble());\n  setBoardButton.disabled = true;\n  emit('clearPosition');\n}\n\nlet cellsToHighlight = [];\nlet cellsToUnhighlight = [];\n\nfunction highlightHoveredCells(positionData) {\n  const { startX, endX, startY, endY, area } = positionData;\n\n  currentBoard.cells.forEach((cell) => {\n    const bound = cell.getBoundingClientRect();\n    const errorTolerance = isWithinBoard(startX, endX, startY, endY) ? 1 : -0.3;\n    const half = bound.width / 2 + errorTolerance;\n    // errorTolerance provides some leeway to pass comparisons (rounding errors, etc.);\n    // however, if the image is not fully within the board, comparisons need to be stricter to avoid\n    // highlighting a set of cells with the wrong dimensions (the check in commitValidHighlights\n    // is not helpful in this case because the size of the set could still be within the limit)\n\n    const maxLeft = bound.left + half;\n    const minRight = bound.right - half;\n    const maxTop = bound.top + half;\n    const minBottom = bound.bottom - half;\n\n    if (startX < maxLeft && endX > minRight && startY < maxTop && endY > minBottom) {\n      cellsToHighlight.push(cell);\n    } else {\n      cellsToUnhighlight.push(cell);\n    }\n  });\n  commitValidHighlights(area);\n  cellsToHighlight = [];\n  cellsToUnhighlight = [];\n}\n\nfunction commitValidHighlights(targetArea) {\n  // if too many cells are in cellsToHighlight because the image is straddling a border, do nothing.\n  // perform this check before filtering; otherwise a set of cells with the wrong dimensions could\n  // be incorrectly highlighted\n  if (cellsToHighlight.length > targetArea) {\n    return;\n  }\n  cellsToHighlight = cellsToHighlight.filter((cell) => !cell.classList.contains('highlight-placed'));\n  // if cellsToHighlight.length is less than targetArea, image is partially off board or partially over\n  // an already-placed image\n  if (cellsToHighlight.length < targetArea) {\n    cellsToHighlight.forEach((cell) => cell.classList.add('highlight-hovered-invalid'));\n    cellsToUnhighlight.forEach((cell) => cell.classList.remove('highlight-hovered-invalid'));\n    currentBoard.cells.forEach((cell) => cell.classList.remove('highlight-hovered'));\n  } else if (cellsToHighlight.length === targetArea) {\n    cellsToHighlight.forEach((cell) => cell.classList.add('highlight-hovered'));\n    cellsToUnhighlight.forEach((cell) => cell.classList.remove('highlight-hovered'));\n    currentBoard.cells.forEach((cell) => cell.classList.remove('highlight-hovered-invalid'));\n  }\n}\n\nfunction isWithinBoard(startX, endX, startY, endY) {\n  const bound = currentBoard.getBoundingClientRect();\n  return bound.left <= startX && bound.right >= endX && bound.top <= startY && bound.bottom >= endY;\n}\n\nfunction handleRelease(element) {\n  const validArea = currentBoard.cells.filter(\n    (cell) =>\n      cell.classList.contains('highlight-hovered') && !cell.classList.contains('highlight-placed')\n  ).length;\n  if (validArea === element.area) {\n    placeImage(element);\n    element.removeResizeListener();\n    element.remove();\n    updateHighlights();\n  } else {\n    resetDraggedImage(element);\n    removeDraggedHighlights();\n  }\n}\n\nfunction placeImage(element) {\n  const image = newTemplateImage(element.type);\n  const imageWrapper = newTemplateWrapper();\n  const startingCell = currentBoard.cells.findIndex((cell) =>\n    cell.classList.contains('highlight-hovered')\n  );\n\n  adjustForRotation(element, image);\n  imageWrapper.style.gridRow = `${Math.floor(startingCell / currentBoard.numRows) + 1} / span ${\n    element.spanY\n  }`;\n  imageWrapper.style.gridColumn = `${(startingCell % currentBoard.numRows) + 1} / span ${element.spanX}`;\n\n  imageWrapper.appendChild(image);\n  currentBoard.appendChild(imageWrapper);\n  disablePreviewImage(element.type);\n  updateRemainingInstruments(element.type);\n}\n\nfunction updateRemainingInstruments(instrument) {\n  const index = remainingInstruments.indexOf(instrument);\n  if (index > -1) {\n    remainingInstruments.splice(index, 1);\n  }\n  if (remainingInstruments.length === 0) {\n    setBoardButton.disabled = false;\n  }\n}\n\nfunction disablePreviewImage(instrument) {\n  previewContainer.querySelector(`.${instrument}`).classList.add('disabled');\n}\n\nfunction disableAllPreviewImages() {\n  previews.forEach((preview) => preview.classList.add('disabled'));\n  setBoardButton.disabled = false;\n}\n\nfunction enablePreviewImages() {\n  previews.forEach((preview) => preview.classList.remove('disabled'));\n}\n\nfunction newTemplateImage(type) {\n  const image = imageGenerator[type]();\n  image.classList.add('placed-img');\n  return image;\n}\n\nfunction newTemplateWrapper() {\n  const imageWrapper = document.createElement('div');\n  imageWrapper.classList.add('placed-img-wrapper');\n  if (getMode() === 'stealth') {\n    imageWrapper.classList.add('stealth');\n  }\n  return imageWrapper;\n}\n\nfunction removeDraggedHighlights() {\n  currentBoard.cells.forEach((cell) => cell.classList.remove('highlight-hovered'));\n  currentBoard.cells.forEach((cell) => cell.classList.remove('highlight-hovered-invalid'));\n}\n\nfunction updateHighlights() {\n  currentBoard.cells.forEach((cell) => {\n    if (cell.classList.contains('highlight-hovered')) {\n      cell.classList.remove('highlight-hovered');\n      cell.classList.add('highlight-placed');\n    }\n  });\n}\n\nexport { setupDOMBoard, newTemplateImage, newTemplateWrapper, disableAllPreviewImages };\n","/* eslint-disable no-param-reassign */\nimport shipFactory from './ship';\nimport { find1DSets } from './1DSetFinder';\nimport { find2DSets } from './2DSetFinder';\nimport { getShipData } from './DOMAdapter';\nimport { on, off, emit } from './observer';\nimport { rowLength } from './boardSize';\nimport { getEnsemble } from './ensemble';\nimport unresolvedShipList from './unresolvedShips';\n\nexport default function boardFactory(id) {\n  let totalShips = 0;\n  let shipsSunk = 0;\n  let totalHits = 0;\n  let totalSunkHits = 0;\n  const placedShips = [];\n  const squares = [];\n  const remainingShips = { ...getEnsemble() };\n  const unresolvedShips = unresolvedShipList();\n  for (let i = 0; i < rowLength(); i++) {\n    squares[i] = [];\n    for (let j = 0; j < rowLength(); j++) {\n      squares[i][j] = {};\n    }\n  }\n\n  function resetSetup() {\n    totalShips = 0;\n    placedShips.length = 0; // reassigning placedShips to [] messes up reference\n    for (let i = 0; i < rowLength(); i++) {\n      for (let j = 0; j < rowLength(); j++) {\n        delete squares[i][j].ship; // reassigning squares[i][j] to {} similarly causes bugs\n      }\n    }\n  }\n\n  let boundSetPosition;\n  function listenForPosition() {\n    boundSetPosition = setPosition.bind(this);\n    on('setPosition', boundSetPosition); // board listens for setup onto the DOMBoard to be finalized\n    on('clearPosition', resetSetup); // autoSetup() relies on adding ships to the board object, not just the DOMBoard\n  }\n\n  function setPosition(DOMBoard) {\n    off('setPosition', boundSetPosition);\n    off('clearPosition', resetSetup);\n    if (placedShips.length > 0) return; // if there are placedShips, autoSetup() has been called and the data already exists in board object\n\n    const ships = getShipData(DOMBoard);\n    Object.entries(ships).forEach((ship) => {\n      this.placeShip(ship[1], ship[0]);\n    });\n  }\n\n  const isOccupied = (coordsSet) => {\n    for (let i = 0; i < coordsSet.length; i++) {\n      const coords = coordsSet[i];\n      if (squares[coords[0]][coords[1]].ship) return true;\n    }\n    return false;\n  };\n\n  const isAttacked = (coords) => squares[coords[0]][coords[1]].attacked;\n\n  const containsAttack = (coordsSet) => {\n    for (let i = 0; i < coordsSet.length; i++) {\n      const coords = coordsSet[i];\n      const square = squares[coords[0]][coords[1]];\n      if (square.attacked) return true;\n    }\n    return false;\n  };\n\n  const containsMissOrSunkSquare = (coordsSet) => {\n    for (let i = 0; i < coordsSet.length; i++) {\n      const coords = coordsSet[i];\n      const square = squares[coords[0]][coords[1]];\n      if ((square.attacked && !square.ship) || square.sunk) return true;\n      // the engine uses this function for finding moves, and while it should not necessarily know\n      // whether a square contains a ship, it does know about misses (i.e. an attacked square with\n      // no ship). it also does not necessarily know all squares that contain sunk ships, but can\n      // often deduce them by marking hit squares as sunk when there are no unresolved hits\n    }\n    return false;\n  };\n\n  const numAttacksInSet = (coordsSet) => {\n    let attacks = 0;\n    for (let i = 0; i < coordsSet.length; i++) {\n      const coords = coordsSet[i];\n      const square = squares[coords[0]][coords[1]];\n      if (square.attacked) attacks++;\n    }\n    return attacks;\n  };\n\n  const hasUnresolvedHits = () => totalHits > totalSunkHits;\n\n  const outOfRange = (coords) => coords.flat().some((coord) => coord < 0 || coord > rowLength() - 1);\n\n  function placeShip(coords, name) {\n    if (outOfRange(coords)) throw new Error('Ships cannot be placed off the board');\n    if (isOccupied(coords)) throw new Error('Ships cannot be on top of ships');\n\n    const newShip = shipFactory(coords.length, name, coords);\n    coords.forEach((coord) => {\n      squares[coord[0]][coord[1]].ship = newShip;\n    });\n    totalShips++;\n    placedShips.push(newShip);\n  }\n\n  on('attack', receiveAttack);\n\n  function receiveAttack(attackData) {\n    if (attackData.id !== id) return;\n\n    const { coords } = attackData;\n    const square = squares[coords[0]][coords[1]];\n    if (square.attacked) throw new Error('this square has already been attacked');\n    square.attacked = true;\n    if (square.ship) {\n      square.ship.hit();\n      totalHits++;\n      if (square.ship.isSunk()) {\n        handleSinkEvent(this, square);\n      }\n    }\n    emit('boardChange', { squares, id });\n  }\n\n  function handleSinkEvent(board, square) {\n    shipsSunk++;\n    totalSunkHits += square.ship.area;\n    delete remainingShips[square.ship.name];\n    emit('sunk', { id, inst: square.ship.name });\n    square.sunkInstrument = square.ship.name;\n\n    if (!board) return; // attack from DOM interaction to Observer — `this` in receieveAttack is undefined\n    // `this` is definied if called from computer — that's when marking squares is necessary for algorithm\n\n    if (hasUnresolvedHits()) {\n      // square.sunkInstrument = square.ship.name;\n      square.sunk = true;\n      unresolvedShips.add(square.ship);\n      unresolvedShips.resolve(board);\n    } else {\n      unresolvedShips.clear();\n      markSunkSquares();\n    }\n  }\n\n  function markSunkSquares() {\n    for (let i = 0; i < rowLength(); i++) {\n      for (let j = 0; j < rowLength(); j++) {\n        if (squares[i][j].attacked) {\n          squares[i][j].sunk = true;\n        }\n      }\n    }\n  }\n\n  function allShipsSunk() {\n    return totalShips === shipsSunk;\n  }\n\n  // find1DSets is a faster algorithm for finding sets with width or length equal to 1\n  function findSets(conditionFunction, x, y) {\n    if (x === 1 || y === 1) {\n      const length = x === 1 ? y : x;\n      return find1DSets(this, length, conditionFunction);\n    }\n    return find2DSets(this, x, y, conditionFunction);\n  }\n\n  function emptySquares() {\n    const set = [];\n    for (let i = 0; i < squares.length; i++) {\n      for (let j = 0; j < squares.length; j++) {\n        if (!squares[i][j].ship) {\n          set.push([i, j]);\n        }\n      }\n    }\n    return set;\n  }\n\n  return {\n    findSets,\n    isOccupied,\n    containsMissOrSunkSquare,\n    containsAttack,\n    isAttacked,\n    numAttacksInSet,\n    placeShip,\n    receiveAttack,\n    allShipsSunk,\n    emptySquares,\n    listenForPosition,\n    resetSetup,\n    hasUnresolvedHits,\n    remainingShips,\n    placedShips,\n    squares,\n    id,\n    get size() {\n      return squares.length;\n    },\n  };\n}\n","let rows = 10;\n\nfunction rowLength() {\n  return rows;\n}\n\nfunction setRowLength(x) {\n  rows = x;\n}\n\nexport { rowLength, setRowLength };\n","import { rowLength } from './boardSize';\n\nfunction indexToCoordinates(index) {\n  const size = rowLength();\n  const x = index % size;\n  const y = Math.floor(index / size);\n  return [x, y];\n}\n\nfunction coordinatesToIndex(coords) {\n  const size = rowLength();\n  return coords[1] * size + coords[0];\n}\n\nexport { indexToCoordinates, coordinatesToIndex };\n","/* eslint-disable no-param-reassign */\nimport { emit } from './observer';\n\nlet cursorOffsetX;\nlet cursurOffsetY;\n\nfunction dragStart(e) {\n  e.preventDefault();\n  cursorOffsetX = (e.clientX || e.touches[0].screenX) - this.offsetLeft;\n  cursurOffsetY = (e.clientY || e.touches[0].screenY) - this.offsetTop;\n  this.classList.add('grabbing');\n\n  const boundDragMove = dragMove.bind(this);\n\n  document.addEventListener('mousemove', boundDragMove);\n  document.addEventListener(\n    'mouseup',\n    () => {\n      document.removeEventListener('mousemove', boundDragMove);\n      this.classList.remove('grabbing');\n      emit('dragEnd', this);\n    },\n    { once: true }\n  );\n\n  document.addEventListener('touchmove', boundDragMove);\n  document.addEventListener(\n    'touchend',\n    () => {\n      document.removeEventListener('touchmove', boundDragMove);\n      this.classList.remove('grabbing');\n      emit('dragEnd', this);\n    },\n    { once: true }\n  );\n}\n\nfunction dragMove(e) {\n  this.style.top = ((e.clientY || e.touches[0].screenY) - cursurOffsetY).toString() + 'px';\n  this.style.left = ((e.clientX || e.touches[0].screenX) - cursorOffsetX).toString() + 'px';\n  const bound = this.getBoundingClientRect();\n  const positionData = {\n    startX: bound.left,\n    endX: bound.right,\n    startY: bound.top,\n    endY: bound.bottom,\n    area: this.area,\n  };\n\n  emit('dragEvent', positionData);\n}\n\nfunction resetDraggedImage(element) {\n  element.style.top = '';\n  element.style.left = '';\n}\n\nexport { dragStart, resetDraggedImage };\n","/* eslint-disable no-param-reassign */\nimport { coordinatesToIndex, indexToCoordinates } from './coordinates';\n\nfunction selectMove(distribution) {\n  const keys = Object.keys(distribution);\n  if (keys.length === 0) throw new Error('Distribution object is empty');\n  let max = -Infinity;\n  let candidateMoves = [];\n\n  keys.forEach((key) => {\n    if (distribution[key] > max) {\n      candidateMoves = [key];\n      max = distribution[key];\n    } else if (distribution[key] === max) {\n      candidateMoves.push(key);\n    }\n  });\n\n  candidateMoves = candidateMoves.map((el) => indexToCoordinates(Number(el)));\n  const index = Math.floor(Math.random() * candidateMoves.length);\n  const move = candidateMoves[index];\n  return move;\n}\n\nfunction huntDistribution(board) {\n  if (Object.keys(board.remainingShips).length === 0)\n    throw new Error('There are no remaining ships to test');\n  const sets = [];\n  Object.entries(board.remainingShips).forEach((ship) => {\n    const dimensions = ship[1];\n    const set = board.findSets(board.containsAttack, ...dimensions);\n    sets.push(...set);\n  });\n  return sets.flat().reduce((freq, coords) => {\n    const key = coordinatesToIndex(coords);\n    freq[key] = (freq[key] || 0) + 1;\n    return freq;\n  }, {});\n}\n\nfunction targetDistribution(board) {\n  if (Object.keys(board.remainingShips).length === 0)\n    throw new Error('There are no remaining ships to test');\n  const sets = [];\n  Object.entries(board.remainingShips).forEach((ship) => {\n    const dimensions = ship[1];\n    const set = board.findSets(board.containsMissOrSunkSquare, ...dimensions);\n    sets.push(...set);\n  });\n  const distribution = {};\n  sets.forEach((set) => {\n    const n = board.numAttacksInSet(set);\n    const weightedScore = 15 ** n;\n\n    // 15 possible placements containing 1 hit square would be necessary to equal in weight 1 possible\n    // placement containing 2 hit squares, and so on.\n    // Designed to prioritize squares that could complete sets with the highest number of hit squares.\n    // It is not clear that this offers any improvement against random placement, but against\n    // human players it should. Against humans it is more likely that hit squares which could be part of\n    // a large ship are, in fact, part of that ship because a human player is less likely to place ships\n    // in clusters.\n    set\n      .filter((coords) => !board.isAttacked(coords))\n      .forEach((coords) => {\n        const key = coordinatesToIndex(coords);\n        distribution[key] = (distribution[key] || 0) + 1 + weightedScore;\n      });\n  });\n  return distribution;\n}\n\nexport { selectMove, huntDistribution, targetDistribution };\n","let ensemble = {\n  cello: [2, 5],\n  trombone: [1, 5],\n  bassoon: [1, 4],\n  horn: [2, 2],\n  flute: [1, 3],\n  clarinet: [1, 3],\n  violin: [1, 3],\n  trumpet: [1, 3],\n  piccolo: [1, 2],\n};\n\nfunction setEnsemble() {\n  const ensembleInput = document.querySelector('.ensemble-select');\n  const selection = ensembleInput.value;\n\n  switch (selection) {\n    case 'chamber':\n      ensemble = {\n        cello: [2, 5],\n        horn: [2, 2],\n        violin: [1, 3],\n        clarinet: [1, 3],\n        flute: [1, 3],\n      };\n      break;\n    case 'brass':\n      ensemble = {\n        tuba: [2, 3],\n        trombone: [1, 5],\n        horn: [2, 2],\n        trumpet: [1, 3],\n      };\n      break;\n    case 'woodwinds':\n      ensemble = {\n        bassoon: [1, 4],\n        flute: [1, 3],\n        clarinet: [1, 3],\n        oboe: [1, 3],\n        piccolo: [1, 2],\n      };\n      break;\n    case 'strings':\n      ensemble = {\n        bass: [3, 6],\n        cello: [2, 5],\n        viola: [1, 3],\n        violin: [1, 3]\n      };\n      break;\n    case 'harp':\n      ensemble = {\n        harp: [3, 6]\n      };\n      break;\n    case 'percussion':\n      ensemble = {\n        bassdrum: [3, 4],\n        glockenspiel: [3, 2],\n        cymbals: [2, 2],\n        snare: [2, 2],\n        cabasa: [2, 1],\n      };\n      break;\n    default:\n      ensemble = {\n        cello: [2, 5],\n        trombone: [1, 5],\n        bassoon: [1, 4],\n        horn: [2, 2],\n        flute: [1, 3],\n        clarinet: [1, 3],\n        violin: [1, 3],\n        trumpet: [1, 3],\n        piccolo: [1, 2],\n      };\n  }\n}\n\nfunction getEnsemble() {\n  return ensemble;\n}\n\nexport { setEnsemble, getEnsemble };\n","/* eslint-disable no-return-assign */\nimport boardFactory from './board';\nimport { humanPlayerFactory, computerPlayerFactory } from './player';\nimport { DOMBoardFactory } from './DOMBoard';\nimport {\n  showBoards,\n  setSetupPanelView,\n  setGamePanelView,\n  resetDOM,\n  updateFleet,\n  coverBoards,\n  coverFleets,\n  setPlayRoundView,\n  setBoardSizes,\n  showInfoButtons,\n  broadcastSunkShip,\n  broadcastWin,\n} from './DOMController';\nimport { rowLength } from './boardSize';\nimport { on, emit, removeAllEvents } from './observer';\nimport { removeWindowEvents } from './imageGenerator';\nimport { setEnsemble } from './ensemble';\nimport { moveTrackerFactory } from './moveTracker';\nimport { setMode } from './mode';\n\nconst controlPanel = document.querySelector('.control-panel');\nconst startButton = document.querySelector('.start-game');\nconst setBoardButton = document.querySelector('.set-board');\nconst switchButton = document.querySelector('.switch-turns');\nconst startRoundButton = document.querySelector('.start-round');\nconst attackDirection = document.querySelector('.attack-direction');\nconst gameState = document.querySelector('.game-state');\n\nconst resetButton = document.querySelector('.reset');\nresetButton.addEventListener('click', reset);\n\nstartButton.addEventListener('click', beginSetup);\nswitchButton.addEventListener('click', coverBoards);\nswitchButton.addEventListener('click', coverFleets);\nstartRoundButton.addEventListener('click', playRound);\n\nconst moveTracker1 = moveTrackerFactory('moves1');\nconst moveTracker2 = moveTrackerFactory('moves2');\n\nconst autoSetupButton = document.querySelector('.random');\n\nlet player1;\nlet player2;\nlet currentPlayer;\n\nlet DOMBoard1;\nlet DOMBoard2;\n\nlet attackCount = 0;\nlet attackMax = 3;\nconst computerMoveTime = 700;\n\nlet sinkDelay = 0; // delay computer start if last move sank a ship\n\nfunction beginSetup() {\n  setEnsemble();\n  setSetupPanelView();\n  setBoardSizes();\n  setMode();\n  attackMax = Number(document.getElementById('move-select').value);\n  const board1 = boardFactory('board1');\n  const board2 = boardFactory('board2');\n  DOMBoard1 = DOMBoardFactory('board1', rowLength());\n  DOMBoard2 = DOMBoardFactory('board2', rowLength());\n  player1 = humanPlayerFactory(board1, board2, DOMBoard1, DOMBoard2, moveTracker1);\n  player2 =\n    document.getElementById('opponent-select').value === 'computer'\n      ? computerPlayerFactory(board2, board1, DOMBoard2, moveTracker2)\n      : (player2 = humanPlayerFactory(board2, board1, DOMBoard2, DOMBoard1, moveTracker2));\n  player1.setup();\n  autoSetupButton.addEventListener('click', player1.autoSetup);\n  setBoardButton.addEventListener('click', finishSetup, { once: true });\n}\n\nfunction finishSetup() {\n  autoSetupButton.removeEventListener('click', player1.autoSetup);\n  player2.setup();\n  if (player2.isComputer()) {\n    startGame();\n  } else {\n    controlPanel.classList.add('two-player');\n    autoSetupButton.addEventListener('click', player2.autoSetup);\n    setBoardButton.addEventListener('click', startGame, { once: true });\n  }\n}\n\nfunction startGame() {\n  setGamePanelView();\n  showInfoButtons();\n  moveTracker1.reset(attackMax);\n  moveTracker2.reset(attackMax);\n  on('sunk', setSinkDelay);\n  on('sunk', updateFleet);\n  on('sunk', broadcastSunkShip);\n  on('attack', postAttackContinuation); // must be after 'attack' subscription from board.js; (computer attack does not emit this event)\n  on('game-over', broadcastWin);\n  DOMBoard1.listenForAttack();\n  DOMBoard2.listenForAttack();\n  currentPlayer = player1;\n  moveTracker1.show();\n  if (player2.isComputer()) {\n    playRound();\n    showBoards();\n  } else {\n    coverBoards();\n    setTimeout(() => {\n      showBoards();\n      currentPlayer.setTurn();\n    }, 2000); // wait for curtain to fully cover boards before changing setup-board to board1\n  }\n}\n\nfunction playRound() {\n  setPlayRoundView();\n  currentPlayer.setTurn();\n  if (currentPlayer.isComputer()) {\n    resetButton.disabled = true;\n    setTimeout(() => {\n      resetButton.disabled = false;\n    }, attackMax * computerMoveTime + 1800 + sinkDelay);\n    setTimeout(switchMoveTracker, 500);\n    setTimeout(computerAttacks, 1000 + sinkDelay);\n  } else {\n    switchMoveTracker();\n  }\n}\n\nfunction postAttackContinuation() {\n  // only runs after a player's attack, not the computer's\n  currentPlayer.incrementMoveCounter();\n  if (currentPlayer.sunkAllShips()) {\n    gameOver();\n    return;\n  }\n  attackCount++;\n  if (attackCount >= attackMax) {\n    attackCount = 0;\n    if (!player2.isComputer()) {\n      attackDirection.classList.add('opaque');\n    }\n    switchTurns();\n    finishRound();\n  }\n}\n\nfunction finishRound() {\n  if (player2.isComputer()) {\n    playRound();\n  } else {\n    DOMBoard1.disable();\n    DOMBoard2.disable();\n    switchButton.disabled = false;\n  }\n}\n\nfunction computerAttacks(i = 0) {\n  if (i >= attackMax) {\n    switchTurns();\n    setTimeout(() => playRound(), computerMoveTime);\n    return;\n  }\n\n  setTimeout(() => {\n    currentPlayer.attack();\n    if (currentPlayer.sunkAllShips()) {\n      gameOver();\n      return;\n    }\n    computerAttacks(i + 1);\n  }, computerMoveTime);\n}\n\nfunction switchTurns() {\n  currentPlayer = currentPlayer === player1 ? player2 : player1;\n}\n\nfunction switchMoveTracker() {\n  if (currentPlayer === player1) {\n    moveTracker1.show();\n    moveTracker2.hide();\n    attackDirection.classList.remove('player2');\n    if (player2.isComputer()) {\n      attackDirection.classList.remove('computer');\n    }\n  } else {\n    moveTracker1.hide();\n    moveTracker2.show();\n    attackDirection.classList.add('player2');\n    if (player2.isComputer()) {\n      attackDirection.classList.add('computer');\n    }\n  }\n}\n\nfunction setSinkDelay() {\n  sinkDelay = 1700;\n  setTimeout(() => sinkDelay = 0, 1000);\n}\n\nfunction gameOver() {\n  gameState.textContent = 'Wins!';\n  const playerID = currentPlayer === player1 ? 1 : 2;\n  emit('game-over', playerID);\n  DOMBoard1.setGameOver();\n  DOMBoard2.setGameOver();\n}\n\nfunction reset() {\n  resetDOM();\n  removeAllEvents();\n  removeWindowEvents();\n  attackCount = 0;\n  DOMBoard1.unlistenForAttack();\n  DOMBoard2.unlistenForAttack();\n  setBoardButton.removeEventListener('click', finishSetup, { once: true });\n  setBoardButton.removeEventListener('click', startGame, { once: true });\n  autoSetupButton.removeEventListener('click', player1.autoSetup);\n  autoSetupButton.removeEventListener('click', player2.autoSetup);\n}\n","/* eslint-disable no-param-reassign */\nimport { resetRotationAdjustment } from './rotatable';\n\nlet windowEvents = [];\n\nfunction flute() {\n  return newImage('flute', 1, 3);\n}\n\nfunction trombone() {\n  const image = newImage('trombone', 1, 5);\n  image.classList.add('stretch-trombone');\n  return image;\n}\n\nfunction clarinet() {\n  return newImage('clarinet', 1, 3);\n}\n\nfunction violin() {\n  const image = newImage('violin', 1, 3);\n  image.classList.add('stretch-violin');\n  return image;\n}\n\nfunction bassoon() {\n  return newImage('bassoon', 1, 4);\n}\n\nfunction cello() {\n  return newImage('cello', 2, 5);\n}\n\nfunction horn() {\n  return newImage('horn', 2, 2);\n}\n\nfunction piccolo() {\n  return newImage('piccolo', 1, 2);\n}\n\nfunction trumpet() {\n  const image = newImage('trumpet', 1, 3);\n  image.classList.add('stretch-trumpet');\n  return image;\n}\n\nfunction bass() {\n  return newImage('bass', 3, 6);\n}\nfunction bassdrum() {\n  return newImage('bassdrum', 3, 4);\n}\nfunction cymbals() {\n  return newImage('cymbals', 2, 2);\n}\nfunction glockenspiel() {\n  return newImage('glockenspiel', 3, 2);\n}\nfunction harp() {\n  return newImage('harp', 3, 6);\n}\nfunction oboe() {\n  return newImage('oboe', 1, 3);\n}\nfunction snare() {\n  return newImage('snare', 2, 2);\n}\nfunction cabasa() {\n  return newImage('cabasa', 1, 2);\n}\nfunction viola() {\n  const image = newImage('viola', 1, 3);\n  image.classList.add('stretch-viola');\n  return image;\n}\nfunction tuba() {\n  return newImage('tuba', 2, 3);\n}\n\nfunction newImage(type, width, height) {\n  const image = new Image();\n  image.src = `./images/${type}.png`;\n  image.spanX = width;\n  image.spanY = height;\n  image.area = width * height;\n  image.type = type;\n  setImageSize(image);\n  const boundResetImageSize = resetImageSize.bind(null, image);\n  window.addEventListener('resize', boundResetImageSize);\n  windowEvents.push(boundResetImageSize);\n  image.removeResizeListener = () => window.removeEventListener('resize', boundResetImageSize);\n  return image;\n}\n\nfunction setImageSize(image) {\n  const cell = document.querySelector('.board:not(.hidden) > .cell');\n  const squareWidth = cell.offsetWidth;\n  image.style.width = `${squareWidth * image.spanX}px`;\n  image.style.height = `${squareWidth * image.spanY}px`;\n}\n\nfunction resetImageSize(image) {\n  setImageSize(image);\n  resetRotationAdjustment(image);\n}\n\nfunction removeWindowEvents() {\n  windowEvents.forEach((event) => {\n    window.removeEventListener('resize', event);\n  });\n  windowEvents = [];\n}\n\nexport {\n  clarinet,\n  flute,\n  trombone,\n  violin,\n  bassoon,\n  cello,\n  horn,\n  trumpet,\n  piccolo,\n  bass,\n  bassdrum,\n  cymbals,\n  glockenspiel,\n  cabasa,\n  harp,\n  oboe,\n  snare,\n  viola,\n  tuba,\n  removeWindowEvents,\n};\n","const modeSelect = document.querySelector('#mode');\nlet mode = 'standard';\n\nfunction setMode() {\n  mode = modeSelect.value;\n}\n\nfunction getMode() {\n  return mode;\n}\n\nexport {\n  setMode,\n  getMode\n}","export function moveTrackerFactory(id) {\n  const tracker = document.getElementById(id);\n  tracker.moves = [];\n\n  let current = 0;\n\n  function hide() {\n    tracker.classList.add('invisible');\n  }\n\n  function show() {\n    tracker.classList.remove('invisible');\n    tracker.moves.forEach((move) => {\n      move.classList.remove('moved');\n    });\n    current = 0;\n  }\n\n  function reset(n) {\n    current = 0;\n    tracker.innerHTML = '';\n    tracker.moves = [];\n    for (let i = 0; i < n; i++) {\n      const move = document.createElement('span');\n      move.classList.add('move');\n      tracker.moves[i] = move;\n      tracker.appendChild(move);\n    }\n  }\n\n  function increment() {\n    tracker.moves[current].classList.add('moved');\n    current++;\n  }\n\n  return {\n    hide,\n    show,\n    reset,\n    increment,\n  };\n}\n","let events = {};\n\nfunction on(eventName, fn) {\n  events[eventName] ||= [];\n  events[eventName].push(fn);\n}\n\nfunction off(eventName, fn) {\n  if (!events[eventName]) return;\n\n  for (let i = 0; i < events[eventName].length; i++) {\n    if (events[eventName][i] === fn) {\n      events[eventName].splice(i, 1);\n      break;\n    }\n  }\n}\n\nfunction emit(eventName, data) {\n  if (!events[eventName]) return;\n\n  events[eventName].forEach((fn) => fn(data));\n}\n\nfunction removeAllEvents() {\n  events = {};\n}\n\nexport { on, off, emit, removeAllEvents };\n","import { rowLength } from './boardSize';\nimport { getEnsemble } from './ensemble';\nimport { huntDistribution, targetDistribution, selectMove } from './engine';\n\nfunction humanPlayerFactory(homeBoard, opponentBoard, homeDOMBoard, opponentDOMBoard, moveCounter) {\n  const ships = getEnsemble();\n\n  function setup() {\n    homeDOMBoard.setupBoard();\n    homeBoard.listenForPosition();\n  }\n\n  function setTurn() {\n    opponentDOMBoard.setDefense();\n    opponentDOMBoard.enable();\n    homeDOMBoard.setOffense();\n  }\n\n  function autoSetup() {\n    homeBoard.resetSetup();\n    Object.entries(ships).forEach((ship) => {\n      const name = ship[0];\n      const dimensions = ship[1];\n      const set = homeBoard.findSets(homeBoard.isOccupied, ...dimensions);\n      const coords = set[Math.floor(Math.random() * set.length)];\n      homeBoard.placeShip(coords, name);\n    });\n    homeDOMBoard.placeSetImages(homeBoard);\n  }\n\n  function isComputer() {\n    return false;\n  }\n\n  function sunkAllShips() {\n    return opponentBoard.allShipsSunk();\n  }\n\n  function incrementMoveCounter() {\n    moveCounter.increment();\n  }\n\n  return { isComputer, setup, autoSetup, setTurn, sunkAllShips, incrementMoveCounter };\n}\n\nfunction computerPlayerFactory(homeBoard, opponentBoard, homeDOMBoard, moveCounter) {\n  const ships = getEnsemble();\n  const size = rowLength();\n  const possibleMoves = [];\n  for (let i = 0; i < size; i++) {\n    for (let j = 0; j < size; j++) {\n      possibleMoves.push([i, j]);\n    }\n  }\n\n  function isComputer() {\n    return true;\n  }\n\n  function attack() {\n    const distribution = opponentBoard.hasUnresolvedHits()\n      ? targetDistribution(opponentBoard)\n      : huntDistribution(opponentBoard);\n\n    const move = selectMove(distribution);\n    opponentBoard.receiveAttack({ id: opponentBoard.id, coords: move });\n    moveCounter.increment();\n  }\n\n  function setup() {\n    Object.entries(ships).forEach((ship) => {\n      const name = ship[0];\n      const dimensions = ship[1];\n      const set = homeBoard.findSets(homeBoard.isOccupied, ...dimensions);\n      const coords = set[Math.floor(Math.random() * set.length)];\n      homeBoard.placeShip(coords, name);\n    });\n    homeDOMBoard.placeSetImages(homeBoard);\n  }\n\n  function setTurn() {\n    homeDOMBoard.disable();\n  }\n\n  function sunkAllShips() {\n    return opponentBoard.allShipsSunk();\n  }\n\n  return { attack, setup, isComputer, setTurn, sunkAllShips };\n}\n\nexport { humanPlayerFactory, computerPlayerFactory };\n","/* eslint-disable no-param-reassign */\nconst rotateButton = document.querySelector('.rotate');\nrotateButton.addEventListener('click', rotate);\n\nlet currentStagedImage;\n\nfunction rotate() {\n  if (!currentStagedImage) return;\n  const rotation = Number(currentStagedImage.style.transform.match(/\\d+(?=deg)/)) % 360;\n  currentStagedImage.style.transform = `rotate(${rotation + 90}deg)`;\n}\n\nfunction setStagedImage(current) {\n  currentStagedImage = current;\n}\n\nfunction adjustForRotation(draggedImage, newImage) {\n  const rotation = Number(draggedImage.style.transform.match(/\\d+(?=deg)/)) % 360;\n  if (!rotation) return;\n  switch (rotation) {\n    case 90:\n      newImage.style.transform = `translateX(${newImage.style.height}) rotate(${rotation}deg)`;\n      break;\n    case 180:\n      newImage.style.transform = `translateY(100%) translateX(100%) rotate(${rotation}deg)`;\n      break;\n    default: // 270\n      newImage.style.transform = `translateY(${newImage.style.width}) rotate(${rotation}deg)`;\n  }\n  if (rotation !== 180) {\n    [draggedImage.spanY, draggedImage.spanX] = [draggedImage.spanX, draggedImage.spanY];\n  }\n}\n\nfunction resetRotationAdjustment(image) {\n  const rotation = Number(image.style.transform.match(/\\d+(?=deg)/));\n  const { height, width } = image.style;\n  if (rotation === 90) {\n    image.style.transform = image.style.transform.replace(/\\d+px/, height); // replace translateX value\n  } else if (rotation === 270) {\n    image.style.transform = image.style.transform.replace(/\\d+px/, width); // replace translateY value\n  }\n}\n\nexport { rotate, setStagedImage, adjustForRotation, resetRotationAdjustment };\n","export default function shipFactory(area, name, coordinateSet) {\n  let hits = 0;\n  const coords = coordinateSet;\n  const hit = () => {\n    if (hits < area) {\n      hits++;\n    } else {\n      throw new Error('You already sank this ship!');\n    }\n  };\n  const isSunk = () => hits === area;\n  return { hit, isSunk, name, coords, area };\n}\n","export default function message(player, inst) {\n  return `${player}'s ${instName(inst)} ${verb(inst)} been sunk!`;\n}\n\nfunction instName(inst) {\n  switch (inst) {\n    case 'bass':\n      return 'double bass';\n    case 'bassdrum':\n      return 'bass drum';\n    case 'horn':\n      return 'french horn';\n    case 'snare':\n      return 'snare drum';\n    default:\n      return inst;\n  }\n}\n\nfunction verb(inst) {\n  return inst === 'cymbals' ? 'have' : 'has';\n}\n","/* eslint-disable no-param-reassign */\nimport { getEnsemble } from './ensemble';\nimport { find2DSets } from './2DSetFinder';\n\nexport default function unresolvedShipList() {\n  let list = [];\n\n  function resolve(board) {\n    for (let i = 0; i < list.length; i++) {\n      const { name } = list[i];\n      const [width, height] = [...getEnsemble()[name]];\n      const invalidPlacement = makeConditionFunction(board, name);\n      const set = find2DSets(board, width, height, invalidPlacement);\n      // find2DSets must be used because it can check that a set includes one square that meets a condition\n      // find1DSets looks at each square individually for conditions that would disqualify a set\n\n      if (set.length === 0) {\n        throw new Error(`No possible sets found for ${name}`);\n      } else if (set.length === 1) {\n        markSunkSquares(board, set[0]);\n        remove(name);\n        resolve(board);\n        break;\n      }\n    }\n  }\n\n  function markSunkSquares(board, set) {\n    set.forEach((coords) => {\n      board.squares[coords[0]][coords[1]].sunk = true;\n    });\n  }\n\n  function makeConditionFunction(board, name) {\n    return function conditionFunction(coordsSet) {\n      if (\n        !coordsSet.some((coords) => {\n          const square = board.squares[coords[0]][coords[1]];\n          return square.sunkInstrument === name;\n        })\n      ) {\n        return true;\n      }\n      if (\n        coordsSet.some((coords) => {\n          const square = board.squares[coords[0]][coords[1]];\n          return !square.attacked || (square.sunk && square.sunkInstrument !== name);\n        })\n      ) {\n        return true;\n      }\n\n      return false;\n    };\n  }\n\n  function add(ship) {\n    // list is ordered from largest to smallest because larger instruments\n    // are more likely to have only one possible placement\n    for (let i = 0; i < list.length; i++) {\n      if (ship.area > list[i].area) {\n        list.splice(i, 0, ship);\n        return;\n      }\n    }\n    list.push(ship);\n  }\n\n  function remove(name) {\n    for (let i = 0; i < list.length; i++) {\n      if (name === list[i].name) {\n        list.splice(i, 1);\n        return;\n      }\n    }\n    throw new Error('No instrument found to remove');\n  }\n\n  function clear() {\n    list = [];\n  }\n\n  return {\n    resolve,\n    add,\n    clear,\n  };\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import './gameflow';\n"],"names":[],"sourceRoot":""}